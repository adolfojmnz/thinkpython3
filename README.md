**Table of Contents**

1. General Introduction
<br/>1.1. The Way of the Program
<br/>1.2. Algorithms
<br/>1.3. The Python Programming Language
<br/>1.4. Executing Python in this Book
<br/>1.5. More About Programs
<br/>1.6. What is Debugging?
<br/>1.7. Syntax errors
<br/>1.8. Runtime Errors
<br/>1.9. Semantic Errors
<br/>1.10. Experimental Debugging
<br/>1.11. Formal and Natural Languages
<br/>1.12. A Typical First Program
<br/>1.13. Comments
<br/>1.14. Glossary
<br/>1.15. Exercises
2. Simple Python Data
<br/>2.1. Variables, Expressions and Statements
<br/>2.2. Values and Data Types
<br/>2.3. Type conversion functions
<br/>2.4. Variables
<br/>2.5. Variable Names and Keywords
<br/>2.6. Statements and Expressions
<br/>2.7. Operators and Operands
<br/>2.8. Input
<br/>2.9. Order of Operations
<br/>2.10. Reassignment
<br/>2.10.1. Developing your mental model of How Python Evaluates
<br/>2.11. Updating Variables
<br/>2.12. Glossary
<br/>2.13. Exercises
3. Debugging Interlude 1
<br/>3.1. How to be a Successful Programmer
<br/>3.2. How to Avoid Debugging
<br/>3.3. Beginning tips for Debugging
<br/>3.4. Know Your Error Messages
<br/>3.4.1. ParseError
<br/>3.4.2. TypeError
<br/>3.4.3. NameError
<br/>3.4.4. ValueError
<br/>3.5. Summary
<br/>3.6. Exercises
4. Python Turtle Graphics
<br/>4.1. Hello Little Turtles!
<br/>4.2. Our First Turtle Program
<br/>4.3. Instances — A Herd of Turtles
<br/>4.4. The for Loop
<br/>4.5. Flow of Execution of the for Loop
<br/>4.6. Iteration Simplifies our Turtle Program
<br/>4.7. The range Function
<br/>4.8. A Few More turtle Methods and Observations
<br/>4.9. Summary of Turtle Methods
<br/>4.10. Glossary
<br/>4.11. Exercises
5. Python Modules
<br/>5.1. Modules and Getting Help
<br/>5.2. More About Using Modules
<br/>5.3. The math module
<br/>5.4. The random module
<br/>5.5. Creating Modules
<br/>5.6. Glossary
<br/>5.7. Exercises
6. Functions
<br/>6.1. Functions
<br/>6.2. Functions that Return Values
<br/>6.3. Unit Testing
<br/>6.3.1. assert with for loops
<br/>6.3.2. Return Value Tests
<br/>6.4. Variables and Parameters are Local
<br/>6.5. The Accumulator Pattern
<br/>6.5.1. The General Accumulator Pattern
<br/>6.5.2. A Variation on the Accumulator Pattern
<br/>6.6. Functions can Call Other Functions
<br/>6.7. Flow of Execution Summary
<br/>6.8. Using a Main Function
<br/>6.9. Program Development
<br/>6.10. Composition
<br/>6.11. A Turtle Bar Chart
<br/>6.12. Glossary
<br/>6.13. Exercises
7. Selection
<br/>7.1. Boolean Values and Boolean Expressions
<br/>7.2. Logical operators
<br/>7.2.1. Logical Opposites
<br/>7.3. Precedence of Operators
<br/>7.4. Conditional Execution: Binary Selection
<br/>7.5. Omitting the else Clause: Unary Selection
<br/>7.6. Nested conditionals
<br/>7.7. Chained conditionals
<br/>7.8. Boolean Functions
<br/>7.8.1. More Unit Testing
<br/>7.9. Glossary
<br/>7.10. Exercises
8. More About Iteration
<br/>8.1. Iteration Revisited
<br/>8.2. The for loop revisited
<br/>8.3. The while Statement
<br/>8.4. Randomly Walking Turtles
<br/>8.5. The 3n + 1 Sequence
<br/>8.6. Newton’s Method
<br/>8.7. The Accumulator Pattern Revisited
<br/>8.8. Other uses of while
<br/>8.8.1. Sentinel Values
<br/>8.8.2. Validating Input
<br/>8.9. Algorithms Revisited
<br/>8.10. Simple Tables
<br/>8.11. 2-Dimensional Iteration: Image Processing
<br/>8.11.1. The RGB Color Model
<br/>8.11.2. Image Objects
<br/>8.11.3. Image Processing and Nested Iteration
<br/>8.12. Image Processing on Your Own
<br/>8.13. Glossary
<br/>8.14. Exercises
9. Strings
<br/>9.1. Strings Revisited
<br/>9.2. A Collection Data Type
<br/>9.3. Operations on Strings
<br/>9.4. Index Operator: Working with the Characters of a String
<br/>9.5. String Methods
<br/>9.5.1. String Format Method
<br/>9.6. Length
<br/>9.7. The Slice Operator
<br/>9.8. String Comparison
<br/>9.9. Strings are Immutable
<br/>9.10. Traversal and the for Loop: By Item
<br/>9.11. Traversal and the for Loop: By Index
<br/>9.12. Traversal and the while Loop
<br/>9.13. The in and not in operators
<br/>9.14. The Accumulator Pattern with Strings
<br/>9.15. Turtles and Strings and L-Systems
<br/>9.16. Looping and Counting
<br/>9.17. A find function
<br/>9.18. Optional parameters
<br/>9.19. Character classification
<br/>9.20. Summary
<br/>9.21. Glossary
<br/>9.22. Exercises
10. Lists
<br/>10.1. Lists
<br/>10.2. List Values
<br/>10.3. List Length
<br/>10.4. Accessing Elements
<br/>10.5. List Membership
<br/>10.6. Concatenation and Repetition
<br/>10.7. List Slices
<br/>10.8. Lists are Mutable
<br/>10.9. List Deletion
<br/>10.10. Objects and References
<br/>10.11. Aliasing
<br/>10.12. Cloning Lists
<br/>10.13. Repetition and References
<br/>10.14. List Methods
<br/>10.15. The Return of L-Systems
<br/>10.16. Append versus Concatenate
<br/>10.17. Lists and for loops
<br/>10.18. The Accumulator Pattern with Lists
<br/>10.18.1. Accumulating the Max Value
<br/>10.18.2. Accumulating a String Result
<br/>10.19. Using Lists as Parameters
<br/>10.20. Pure Functions
<br/>10.21. Which is Better?
<br/>10.22. Functions that Produce Lists
<br/>10.23. List Comprehensions
<br/>10.24. Nested Lists
<br/>10.25. Strings and Lists
<br/>10.26. list Type Conversion Function
<br/>10.27. Tuples and Mutability
<br/>10.28. Tuple Assignment
<br/>10.29. Tuples as Return Values
<br/>10.30. Glossary
<br/>10.31. Exercises
11. Files
<br/>11.1. Working with Data Files
<br/>11.2. Finding a File on your Disk
<br/>11.3. Reading a File
<br/>11.4. Iterating over lines in a file
<br/>11.5. Alternative File Reading Methods
<br/>11.6. Writing Text Files
<br/>11.7. With Statements
<br/>11.8. Fetching Something From The Web
<br/>11.9. Glossary
<br/>11.10. Exercises
12. Dictionaries
<br/>12.1. Dictionaries
<br/>12.2. Dictionary Operations
<br/>12.3. Dictionary Methods
<br/>12.4. Aliasing and Copying
<br/>12.5. Sparse Matrices
<br/>12.6. Glossary
<br/>12.7. Exercises
13. Exceptions
<br/>13.1. What is an exception?
<br/>13.2. Exception Handling Flow-of-control
<br/>13.2.1. Raising and Catching Errors with try and except
<br/>13.3. Runetime Stack and raise command
<br/>13.4. Summary
<br/>13.5. Standard Exceptions
<br/>13.6. Principles for using Exceptions
<br/>13.7. Exceptions Syntax
<br/>13.7.1. Catch All Exceptions
<br/>13.7.2. Catch A Specific Exception
<br/>13.7.3. Catch Multiple Specific Exceptions
<br/>13.7.4. Clean-up After Exceptions
<br/>13.7.5. An Example of File I/O
<br/>13.8. The finally clause of the try statement
<br/>13.9. Glossary
<br/>13.10. Exercises
14. Web Applications
<br/>14.1. Web Applications
<br/>14.2. How the Web Works
<br/>14.3. How Web Applications Work
<br/>14.4. Web Applications and HTML Forms
<br/>14.5. Writing Web Applications With Flask
<br/>14.6. More About Flask
<br/>14.7. Input For A Flask Web Application
<br/>14.8. Web Applications With a User Interface
<br/>14.9. Glossary
15. GUI and Event Driven Programming
<br/>15.1. Graphical User Interfaces
<br/>15.2. GUI Programming
<br/>15.3. GUI Programming Options
<br/>15.4. TKinter
<br/>15.5. Tkinter Pre-programmed Interfaces
<br/>15.6. Tkinter Custom Interfaces
<br/>15.7. Hello World
<br/>15.8. Tkinter Standard Dialog Boxes
<br/>15.8.1. Messages
<br/>15.8.2. Yes/No Questions
<br/>15.8.3. Single Value Data Entry
<br/>15.8.4. File Chooser
<br/>15.8.5. Color Chooser
<br/>15.9. GUI Widgets
<br/>15.10. Creating Widgets
<br/>15.11. Layout Mangers
<br/>15.12. Specifying Dimensions
<br/>15.13. Place Layout Manager
<br/>15.14. Grid Layout Manager
<br/>15.15. Pack Layout Manager
<br/>15.15.1. Summary
<br/>15.16. Widget Groupings
<br/>15.17. Command Events
<br/>15.18. Hello World Again
<br/>15.19. Other Events
<br/>15.20. Low-Level Event Processing
<br/>15.21. Focus
<br/>15.22. Event Binding
<br/>15.23. Event Descriptors
<br/>15.24. Event Objects
<br/>15.25. Event Processing
<br/>15.26. The Design of GUI Programs
<br/>15.27. Common Widget Properties
<br/>15.28. Specific Widget Properties
<br/>15.29. Widget Attributes
<br/>15.30. Timer Events
<br/>15.30.1. Animations and Repeated Tasks
<br/>15.30.2. Canceling Timer Events
<br/>15.30.3. Multiple Parameters to Timer Callbacks
<br/>15.31. A Programming Example
<br/>15.31.1. A Whack-a-mole Game
<br/>15.31.2. Summary
<br/>15.32. Managing GUI Program Complexity
<br/>15.32.1. Creating the View
<br/>15.32.2. Creating the Model
<br/>15.32.3. Creating the Controller
<br/>15.33. Exercises
<br/>15.34. Glossary
16. Recursion
<br/>16.1. What Is Recursion?
<br/>16.2. Calculating the Sum of a List of Numbers
<br/>16.3. The Three Laws of Recursion
<br/>16.4. Converting an Integer to a String in Any Base
<br/>16.5. Visualizing Recursion
<br/>16.6. Sierpinski Triangle
<br/>16.7. Glossary
<br/>16.8. Programming Exercises
<br/>16.9. Exercises
17. Classes and Objects - the Basics
<br/>17.1. Object-oriented programming
<br/>17.2. A change of perspective
<br/>17.3. Objects Revisited
<br/>17.4. User Defined Classes
<br/>17.5. Improving our Constructor
<br/>17.6. Adding Other Methods to our Class
<br/>17.7. Objects as Arguments and Parameters
<br/>17.8. Converting an Object to a String
<br/>17.9. Instances as Return Values
<br/>17.10. Glossary
<br/>17.11. Exercises
18. Classes and Objects - Digging a Little Deeper
<br/>18.1. Fractions
<br/>18.2. Objects are Mutable
<br/>18.3. Sameness
<br/>18.4. Arithmetic Methods
<br/>18.5. Glossary
<br/>18.6. Exercises
19. Inheritance
<br/>19.1. Pillars of OOP
<br/>19.2. Introduction to Inheritance
<br/>19.3. Extending
<br/>19.4. Reuse Through Composition
<br/>19.5. Class Diagrams
<br/>19.6. Composition vs. Inheritance
<br/>19.7. Case Study: Structured Postal Addresses
<br/>19.7.1. Storing Postal Addresses
<br/>19.7.2. Storing International Addresses
<br/>19.7.3. Inheritance Applied
<br/>19.7.4. A List of Addresses
<br/>19.7.5. Using isinstance
20. Unit Testing
<br/>20.1. Introduction: Unit Testing
<br/>20.2. Checking Assumptions With assert
<br/>20.2.1. Designing Defensive Functions
<br/>20.2.2. The assert Statement
<br/>20.2.3. More on assert and Preconditions
<br/>20.3. Testing Functions
<br/>20.3.1. Automated Unit Tests
<br/>20.3.2. Automated Unit Tests with assert
<br/>20.3.3. Unit Tests can have bugs
<br/>20.4. Designing Testable Functions
<br/>20.4.1. Design by Contract
<br/>20.5. Writing Unit Tests
<br/>20.5.1. Specification-Based Testing
<br/>20.6. Test-First Development
<br/>20.6.1. Benefits of Test-First Development
<br/>20.7. Testing with pytest
<br/>20.7.1. Organizing pytest Functions
<br/>20.7.2. Using pytest
<br/>20.7.3. Understanding pytest Failure Reports
<br/>20.7.4. Integrated Unit Testing with pytest
<br/>20.8. Glossary
<br/>20.9. Exercises
<br/>
